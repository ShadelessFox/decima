package com.shade.decima.rtti.generator;

import com.shade.decima.rtti.generator.data.ClassTypeInfo;
import com.shade.decima.rtti.generator.data.TypeInfo;
import com.shade.util.NotNull;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.QualifiedNameable;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import javax.tools.StandardLocation;
import java.io.IOException;
import java.io.Writer;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Objects;
import java.util.Set;

public class GenerateBindingsProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        var messager = processingEnv.getMessager();

        for (TypeElement annotation : annotations) {
            Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(annotation);

            for (Element element : elements) {
                var meta = element.getAnnotation(GenerateBindings.class);
                var packageName = String.valueOf(((QualifiedNameable) element).getQualifiedName());
                var className = packageName + "." + meta.namespace();

                messager.printMessage(Diagnostic.Kind.NOTE, "Generating type bindings " + className + " using " + meta.source());

                try {
                    var context = new TypeContext();
                    context.load(getModuleRoot().resolve(meta.source()));

                    var types = context.types();
                    messager.printMessage(Diagnostic.Kind.NOTE, "Loaded " + types.size() + " types");

                    var generator = new TypeGenerator();
                    var generated = types.stream()
                        .filter(GenerateBindingsProcessor::filterType)
                        .map(generator::generate)
                        .filter(Objects::nonNull)
                        .toList();

                    var root = TypeSpec.interfaceBuilder(meta.namespace())
                        .addModifiers(Modifier.PUBLIC)
                        .addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
                            .addMember("value", "$S", "all")
                            .build())
                        .addTypes(generated)
                        .build();

                    var file = JavaFile.builder(packageName, root)
                        .addFileComment("This file was autogenerated. Do not edit!")
                        .build();

                    var object = processingEnv.getFiler().createSourceFile(className, element);
                    try (Writer writer = object.openWriter()) {
                        file.writeTo(writer);
                    }

                    messager.printMessage(Diagnostic.Kind.NOTE, "Generated successfully");
                } catch (IOException e) {
                    messager.printMessage(Diagnostic.Kind.ERROR, "Failed to generate type bindings " + className + " using " + meta.source() + ": " + e);
                }
            }
        }

        return true;
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return Set.of(GenerateBindings.class.getName(), BinaryReaderDefinition.class.getName());
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }

    @NotNull
    private Path getModuleRoot() throws IOException {
        var file = processingEnv.getFiler().getResource(StandardLocation.CLASS_OUTPUT, "", "dummy");
        var path = Path.of(file.toUri());
        while (Files.notExists(path.resolve("build.gradle"))) {
            path = path.getParent();
        }
        return path;
    }

    private static boolean filterType(@NotNull TypeInfo info) {
        return !(info instanceof ClassTypeInfo cls) || !cls.isAssignableTo("ExportedSymbolGroup");
    }
}
